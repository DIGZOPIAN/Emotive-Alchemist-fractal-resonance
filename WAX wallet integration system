// WAX Wallet Integration for DIGZO Virtual World
// Complete authentication and blockchain interaction system

class WAXWalletConnector {
constructor(gameEngine) {
this.gameEngine = gameEngine;
this.wax = null;
this.userAccount = null;
this.isConnected = false;
this.contractName = ‘alpha.waxfun’;
this.tokenSymbol = ‘DIGZO’;

```
    this.initializeWAX();
}

async initializeWAX() {
    try {
        // Initialize WAX CloudWallet
        const { WAX } = await import('https://unpkg.com/@waxio/waxjs@1.0.5/dist/waxjs.umd.js');
        
        this.wax = new WAX({
            rpcEndpoint: 'https://wax.greymass.com',
            tryAutoLogin: true,
            userAccount: this.userAccount,
            pubKeys: []
        });

        console.log('WAX Wallet initialized');
        
        // Auto-login if previously connected
        await this.tryAutoLogin();
        
    } catch (error) {
        console.error('WAX initialization failed:', error);
        throw new Error('Failed to initialize WAX wallet connection');
    }
}

async tryAutoLogin() {
    try {
        if (this.wax) {
            this.userAccount = await this.wax.login();
            if (this.userAccount) {
                this.isConnected = true;
                await this.onWalletConnected();
            }
        }
    } catch (error) {
        console.log('Auto-login not available, manual login required');
    }
}

async connectWallet() {
    try {
        if (!this.wax) {
            throw new Error('WAX not initialized');
        }

        // Prompt user for wallet connection
        this.userAccount = await this.wax.login();
        
        if (this.userAccount) {
            this.isConnected = true;
            await this.onWalletConnected();
            
            return {
                success: true,
                account: this.userAccount,
                message: 'Wallet connected successfully'
            };
        } else {
            throw new Error('Failed to connect wallet');
        }
    } catch (error) {
        console.error('Wallet connection failed:', error);
        return {
            success: false,
            error: error.message
        };
    }
}

async onWalletConnected() {
    try {
        // Get player's DIGZO balance
        const balance = await this.getTokenBalance();
        
        // Initialize player in game engine
        await this.gameEngine.initializePlayer(this.userAccount);
        
        // Update UI
        this.updateWalletUI(balance);
        
        // Set up real-time balance monitoring
        this.startBalanceMonitoring();
        
        console.log(`Player ${this.userAccount} connected with ${balance} DIGZO`);
        
    } catch (error) {
        console.error('Post-connection setup failed:', error);
    }
}

async getTokenBalance() {
    try {
        const result = await this.wax.rpc.get_currency_balance(
            this.contractName,
            this.userAccount,
            this.tokenSymbol
        );
        
        const balance = result.length > 0 ? parseFloat(result[0].split(' ')[0]) : 0;
        return balance;
        
    } catch (error) {
        console.error('Balance fetch failed:', error);
        return 0;
    }
}

async transferTokens(toAccount, amount, memo = '') {
    try {
        if (!this.isConnected) {
            throw new Error('Wallet not connected');
        }

        const result = await this.wax.api.transact({
            actions: [{
                account: this.contractName,
                name: 'transfer',
                authorization: [{
                    actor: this.userAccount,
                    permission: 'active'
                }],
                data: {
                    from: this.userAccount,
                    to: toAccount,
                    quantity: `${amount.toFixed(8)} ${this.tokenSymbol}`,
                    memo: memo
                }
            }]
        }, {
            blocksBehind: 3,
            expireSeconds: 30
        });

        return {
            success: true,
            transactionId: result.transaction_id,
            amount: amount,
            to: toAccount
        };

    } catch (error) {
        console.error('Transfer failed:', error);
        return {
            success: false,
            error: error.message
        };
    }
}

// Game-specific blockchain actions
async executeGameAction(action, data = {}) {
    try {
        let result;
        
        switch (action) {
            case 'claim_reward':
                result = await this.claimGameReward(data.amount, data.source);
                break;
                
            case 'purchase_land':
                result = await this.purchaseLandNFT(data.landId, data.price);
                break;
                
            case 'mint_nft':
                result = await this.mintGameNFT(data.nftData);
                break;
                
            case 'stake_tokens':
                result = await this.stakeTokens(data.amount, data.duration);
                break;
                
            default:
                throw new Error(`Unknown action: ${action}`);
        }
        
        return result;
        
    } catch (error) {
        console.error(`Game action ${action} failed:`, error);
        return { success: false, error: error.message };
    }
}

async claimGameReward(amount, source) {
    // In a full implementation, this would call a smart contract
    // For now, we simulate the reward claim
    
    const transaction = {
        action: 'reward_claim',
        player: this.userAccount,
        amount: amount,
        source: source,
        timestamp: Date.now()
    };
    
    // Update game engine
    await this.gameEngine.rewardPlayer(this.userAccount, amount, source);
    
    // In production, trigger actual blockchain transaction here
    console.log('Reward claimed:', transaction);
    
    return {
        success: true,
        transaction: transaction,
        newBalance: await this.getTokenBalance()
    };
}

async purchaseLandNFT(landId, price) {
    try {
        // Simulate land purchase transaction
        const landData = {
            id: landId,
            owner: this.userAccount,
            price: price,
            coordinates: [Math.floor(Math.random() * 100), Math.floor(Math.random() * 100)],
            size: 'medium',
            purchaseDate: Date.now()
        };

        // Process payment
        await this.gameEngine.spendTokens(this.userAccount, price, 'land_purchase');
        
        // In production, this would mint actual NFT on blockchain
        console.log('Land NFT purchased:', landData);
        
        return {
            success: true,
            landData: landData,
            transactionCost: price
        };
        
    } catch (error) {
        return { success: false, error: error.message };
    }
}

async mintGameNFT(nftData) {
    try {
        const cost = 3.0; // 3 DIGZO to mint NFT
        
        // Check balance
        const balance = await this.getTokenBalance();
        if (balance < cost) {
            throw new Error('Insufficient DIGZO balance for NFT minting');
        }
        
        // Create NFT metadata
        const nft = {
            id: `nft_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
            owner: this.userAccount,
            type: nftData.type || 'character',
            rarity: nftData.rarity || 'common',
            attributes: {
                strength: Math.floor(Math.random() * 100),
                agility: Math.floor(Math.random() * 100),
                intelligence: Math.floor(Math.random() * 100),
                ...nftData.attributes
            },
            mintDate: Date.now(),
            creator: this.userAccount
        };
        
        // Process payment
        await this.gameEngine.spendTokens(this.userAccount, cost, 'nft_minting');
        
        // In production, mint actual NFT on WAX
        console.log('NFT minted:', nft);
        
        return {
            success: true,
            nft: nft,
            cost: cost
        };
        
    } catch (error) {
        return { success: false, error: error.message };
    }
}

async stakeTokens(amount, durationDays = 30) {
    try {
        const apr = 0.12; // 12% APR
        const dailyRate = apr / 365;
        const expectedReward = amount * dailyRate * durationDays;
        
        const stakeData = {
            player: this.userAccount,
            amount: amount,
            duration: durationDays,
            startDate: Date.now(),
            endDate: Date.now() + (durationDays * 24 * 60 * 60 * 1000),
            expectedReward: expectedReward,
            status: 'active'
        };
        
        // Process staking
        await this.gameEngine.spendTokens(this.userAccount, amount, 'token_staking');
        
        // Store stake info (in production, on blockchain)
        console.log('Tokens staked:', stakeData);
        
        return {
            success: true,
            stakeData: stakeData,
            expectedReward: expectedReward
        };
        
    } catch (error) {
        return { success: false, error: error.message };
    }
}

startBalanceMonitoring() {
    // Monitor balance changes every 30 seconds
    this.balanceMonitor = setInterval(async () => {
        if (this.isConnected) {
            const currentBalance = await this.getTokenBalance();
            const playerData = this.gameEngine.getPlayerData(this.userAccount);
            
            if (playerData && currentBalance !== playerData.lastKnownBalance) {
                playerData.lastKnownBalance = currentBalance;
                this.updateWalletUI(currentBalance);
            }
        }
    }, 30000);
}

updateWalletUI(balance) {
    // Update game UI with wallet info
    const walletUI = {
        connected: this.isConnected,
        account: this.userAccount,
        balance: balance,
        balanceFormatted: `${balance.toFixed(4)} DIGZO`
    };
    
    // Emit event for game UI to catch
    if (typeof window !== 'undefined') {
        window.dispatchEvent(new CustomEvent('walletUpdated', { 
            detail: walletUI 
        }));
    }
    
    console.log('Wallet UI updated:', walletUI);
}

disconnect() {
    this.isConnected = false;
    this.userAccount = null;
    
    if (this.balanceMonitor) {
        clearInterval(this.balanceMonitor);
    }
    
    // Update UI
    this.updateWalletUI(0);
    
    console.log('Wallet disconnected');
}

// Utility functions
isWalletConnected() {
    return this.isConnected && this.userAccount !== null;
}

getConnectedAccount() {
    return this.userAccount;
}

async getAccountInfo() {
    if (!this.isConnected) return null;
    
    try {
        const account = await this.wax.rpc.get_account(this.userAccount);
        const balance = await this.getTokenBalance();
        
        return {
            accountName: this.userAccount,
            balance: balance,
            created: account.created,
            ramUsage: account.ram_usage,
            ramQuota: account.ram_quota,
            cpuWeight: account.total_resources?.cpu_weight,
            netWeight: account.total_resources?.net_weight
        };
    } catch (error) {
        console.error('Failed to get account info:', error);
        return null;
    }
}

// Transaction history
async getTransactionHistory(limit = 50) {
    try {
        // In production, query actual blockchain history
        const mockHistory = [
            {
                id: 'tx_001',
                type: 'reward',
                amount: 0.5,
                source: 'quest_completion',
                timestamp: Date.now() - 3600000
            },
            {
                id: 'tx_002', 
                type: 'spend',
                amount: -3.0,
                source: 'nft_minting',
                timestamp: Date.now() - 7200000
            }
        ];
        
        return mockHistory;
    } catch (error) {
        console.error('Failed to get transaction history:', error);
        return [];
    }
}
```

}

// Unity/C# Bridge Functions
window.WAXBridge = {
connector: null,

```
async initialize(gameEngineInstance) {
    this.connector = new WAXWalletConnector(gameEngineInstance);
    return { success: true };
},

async connectWallet() {
    if (!this.connector) throw new Error('WAX Bridge not initialized');
    return await this.connector.connectWallet();
},

async getBalance() {
    if (!this.connector) return 0;
    return await this.connector.getTokenBalance();
},

async executeGameAction(action, data) {
    if (!this.connector) throw new Error('WAX Bridge not initialized');
    return await this.connector.executeGameAction(action, data);
},

isConnected() {
    return this.connector ? this.connector.isWalletConnected() : false;
},

getAccount() {
    return this.connector ? this.connector.getConnectedAccount() : null;
}
```

};

// Export for different environments
if (typeof module !== ‘undefined’ && module.exports) {
module.exports = { WAXWalletConnector, WAXBridge: window.WAXBridge };
}

console.log(‘WAX Wallet Connector initialized - Ready for Unity/Godot integration’);
